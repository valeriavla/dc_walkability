---
title: "Bike Ridership EDA"
author: Madelyne Ventura
date: "4/10/2023"
format:
    html:
        toc: true
        embed-resources: true
        theme: default
        code-copy: true
        code-line-numbers: true
        code-fold: true
---

# Read in Datasets

- GeoJSON for the bikelane data
- Capital Bikeshare dataset for March

```{python}
import pandas as pd
import numpy as np
import altair as alt
import plotly.graph_objects as go
from vega_datasets import data
import requests
import json

```

# Bikeshare Data

Read in the bikeshare dataset. This dataset is for the month of March and was sourced from this [website](https://s3.amazonaws.com/capitalbikeshare-data/index.html).

```{python}
bikeshare_df = pd.read_csv('../data/202303-capitalbikeshare-tripdata.csv')
bikeshare_df.head()
```

Look at the various datatypes
```{python}
print(f'Datatypes of dataset: \n{bikeshare_df.info()}')
print(f'Summary statistics of dataset: \n{bikeshare_df.describe()}')
```

Since the dataset timestamps are `object` datatypes, I will convert them into Pandas datetime.

```{python}
# Convert dates into datetime format
bikeshare_df['started_at'] = pd.to_datetime(bikeshare_df['started_at'])
bikeshare_df['ended_at'] = pd.to_datetime(bikeshare_df['ended_at'])
print(f'Datatypes of dataset: \n{bikeshare_df.info()}')
bikeshare_df.head()
```

```{python}
# Check number of rows in dataset
print(f'Dimensions of dataset: {bikeshare_df.shape}')
```

Next, drop NaNs from the dataset. Since there are some trips where we don't have a starting or ending location, remove them from the dataset.

```{python}
bikeshare_df.dropna(subset=['start_station_name'], inplace = True)
bikeshare_df.dropna(subset=['end_station_name'], inplace = True)
print(f'Dimensions of dataset: {bikeshare_df.shape}')
```

Finally, since Capital Bikeshare bikes start tracking the bikes at their exact latitude and longitude, there are tiny differences between the latitude and longtitude. I am going to standardize the latitude, longitude for both the starting and ending locations.

```{python}
# Standardize longitude and latitude using start station
bikeshare_df['start_lng'] = bikeshare_df['start_lng'].groupby(bikeshare_df['start_station_id']).transform('max')
bikeshare_df['start_lat'] = bikeshare_df['start_lat'].groupby(bikeshare_df['start_station_id']).transform('max')
```

```{python}
# Create dataframe for joining
tmp = bikeshare_df[['start_station_id', 'start_lng','start_lat']]
tmp.drop_duplicates(inplace = True)
print(tmp.start_station_id.nunique())
```

Now that the start longitude and latitude are standardize, I will then make sure that the end latitude and longitude values match for the same stations.

```{python}
# Merge using the common station id value
bikeshare_df = bikeshare_df.merge(tmp, left_on = 'end_station_id', right_on = 'start_station_id')
```

```{python}
# Drop repeated columns and rename them
bikeshare_df.drop(columns = ['end_lat', 'end_lng', 'start_station_id_y'], inplace = True)
bikeshare_df.rename(columns = {'start_lat_x': 'start_lat', 'start_lng_x': 'start_lng', 'start_lat_y': 'end_lat', 'start_lng_y':'end_lng', 'start_station_id_x': 'start_station_id'}, inplace = True)
```

Let's check that the ending and starting stations have unique values for the latitude and longitude values. These should all be values of 1, since we only want a 1-to-1 match.

```{python}
print(f"Checking max nunique value in start lng: {max(bikeshare_df.groupby('start_station_id')['start_lng'].nunique())}")
print(f"Checking max nunique value in start lat: {max(bikeshare_df.groupby('start_station_id')['start_lat'].nunique())}")
print(f"Checking max nunique value in end lat: {max(bikeshare_df.groupby('end_station_id')['end_lat'].nunique())}")
print(f"Checking max nunique value in end lng: {max(bikeshare_df.groupby('end_station_id')['end_lng'].nunique())}")
```

# EDA using `Altair`

First, let's look at the top bike stations in D.C.

```{python}
# Remove limit for Altair
alt.data_transformers.enable('default', max_rows = None)
```

The table below shows the most common places people begin their trips using bikeshare.

```{python}
# Create groupby of top 15 most popular bike stations
grouped_df = bikeshare_df.groupby('start_station_name').agg({'ride_id': 'count'}).reset_index()
grouped_df.rename(columns={'ride_id': 'count_rides'}, inplace = True)
# Keep only top 15
grouped_df = grouped_df.sort_values('count_rides', ascending = False).head(15)
grouped_df
```

We can show this visually using a bar graph in Altair 

```{python}
# Create selection
selection = alt.selection_single(fields=['start_station_name'],name='Random')
color = alt.condition(selection,
                      alt.Color('start_station_name:N', scale= alt.Scale(scheme="accent"), title = "Station Name"),
                      alt.value('lightgray'))
# Make bar graph
bar=(alt.Chart(bikeshare_df[bikeshare_df['start_station_name'].isin(grouped_df['start_station_name'].to_list())])
 .mark_bar()
 .encode(y='count(ride_id):Q',
         x=alt.X('start_station_name:N',
         sort=alt.EncodingSortField(field='ride_id', op='count', 
                            order='descending')),
         color=color,
         tooltip=['start_station_name:N', 'count(ride_id):Q']
        )
).add_selection(selection)

bar.title ="Top 15 Capital Bikeshare Stations"
bar.encoding.x.title = 'Station'
bar.encoding.y.title = 'Count of Rides in March 2023'
bar
```


## Bikeshare Route Visualization

The first visual just plots the station locations without a background.

```{python}
tmp = bikeshare_df[['start_station_name', 'start_lng', 'start_lat']].drop_duplicates()
# Map of points for ride share locations
alt.Chart(tmp).mark_circle().encode(
    longitude='start_lng:Q',
    latitude='start_lat:Q',
    size=alt.value(10),
    tooltip=['start_station_name:N', 'station_count:Q']
).project(
    "albersUsa"
).properties(
    width=500,
    height=400
)
```

The code in the cell below ccreates a background of Washington D.C. This will be used for the different visuals. 

```{python}
# Function to download geojson file
response1 = requests.get('https://raw.githubusercontent.com/arcee123/GIS_GEOJSON_CENSUS_TRACTS/master/11.geojson')

background = alt.Chart(alt.Data(values=response1.json())).mark_geoshape(
        fill="lightgray",
        stroke='white',
        strokeWidth=1
    ).encode(
    ).properties(
        width=600,
        height=600
    )
background
```


```{python}
# Map showing all the bikeshare locations
# Temporary dataframe showing unique station locations
tmp = bikeshare_df[['start_station_name', 'start_lng', 'start_lat']].drop_duplicates()

# Create scatter plot of Start Stations
#chart = alt.Chart(tmp).mark_circle().encode(
#    longitude='start_lat:Q',
#    latitude='start_lng:Q',
#    size=alt.value(100),
#    #color=alt.Color('category:N', legend=None),
#    tooltip=['start_station_id:N', 'count_rides:Q']
#).properties(
#    title='RideShare Locations in Washington D.C.'
#)

# Map of points for ride share locations
chart = alt.Chart(tmp).mark_circle().encode(
    longitude='start_lng:Q',
    latitude='start_lat:Q',
    size=alt.value(10),
    tooltip='start_station_name:N'
)

background + chart
```


```{python}
# Define background of Washington D.C.
background = alt.Chart(alt.Data(values=anc_json)).mark_geoshape(
        fill="lightgray",
        stroke='white',
        strokeWidth=1
    ).encode(
    ).properties(
        width=800,
        height=800
    )

# Create mouseover selection
select_station = alt.selection_single(
    on="mouseover", nearest=True, fields=["start_station_name"]
)

tmp = bikeshare_df[['start_station_name', 'start_lat', 'start_lng', 'end_lat', 'end_lng']].drop_duplicates()
# Define connections
connections = alt.Chart(tmp).mark_rule(opacity=0.35).encode(
    latitude="start_lat:Q",
    longitude="start_lng:Q",
    latitude2="end_lat:Q",
    longitude2="end_lng:Q"
).transform_filter(
    select_station
)


# Temporary dataframe showing unique station locations with ride count
tmp = bikeshare_df[['start_station_name','start_station_id', 'start_lng', 'start_lat', 'ride_id']].groupby(['start_station_name', 'start_station_id','start_lng', 'start_lat']).agg({'ride_id': 'count'}).reset_index()
tmp.rename(columns= {'ride_id':'count_rides'}, inplace = True)

points = alt.Chart(tmp).mark_circle().encode(
    latitude="start_lat:Q",
    longitude="start_lng:Q",
    size=alt.Size("count_rides:Q", scale=alt.Scale(range=[15, 250]), legend=None),
    order=alt.Order("count_rides:Q", sort="descending"),
    tooltip=["start_station_name:N", "start_station_id:Q", "count_rides:Q"]
).add_selection(
    select_station
)

(background + connections + points).configure_view(stroke=None)
#(background  + points).configure_view(stroke=None)
#(background).configure_view(stroke=None)
```


```{python}
# Create list of bikeshare stations outside of DC
nondc_stations = [
    32256,32251,32237,32241,32210,32225,32259,32223,32209,32240,32239,32245,32220,32214,32219,
    32224,32217,32213,32239,32246,32247,32250,32248,32246,32228,32215,32238,32252,32249,32260,
    32234,32231,32235,32255,32200,32208,32201,32211,32227,32207,32229,32221,32206,32233,32205,
    32204,32205,32203,32206,32222,32230,32232,32600,32602,32603,32608,32605,32604,32607,32609,
    31948,31904,32606,32601,31921,31905,31902,31901,31976,31036,31977,31900,31920,31049,31037,
    31926,31919,31035,31973,31069,31023,31022,31021,31019,31020,31094,31092,31079,31030,31029,
    31080,31093,31014,31062,31077,31073,31024,31040,31028,31017,31924,31027,31947,31066,31075,31949,31053,31971,31067,31058,31923,31063,31068,31951,31945,31095,31006,31005,31091,31004,
    31936,31071,31090,31950,31064,31935,31011,31012,31009,31944,31052,31010,31959,31916,31088,
    31960,31956,31910,31083,31915,31087,31085,31913,31915,31970,31969,31906,31098,31048,31081,
    31084,31082,31974,31930,31932,31953,31942,31967,32406,32423,32415,32407,32405,32401,32400,
    32405,32404,32413,32418,32410,32403,32408,32421,32402,32417,32422,32420,32414,32412,32416,
    32059,32061,32026,32011,32049,32082,32058,32025,32001,32058,32082,32024,32043,32036,32012,
    32034,32035,32050,32056,32426,32425,32424,32426,32085,32094,32089,32093,32091,32090,32087,
    32088,32086,32092,32022,32066,32064,32062,32065,32073,32063,32084,32054,32051,32040,32046,
    32029,32055,32002,32021,32003,32048,32013,32000,32008,32028,32027,32053,32039,32057,32078,
    32075,32077,32076,32079,32080,32074,32081,32032,32047,32044,32017,32007,32009,32023,32033,
    32016,32004,32005,32072,32041,32052,32071,32038,32037,32045,32067,32069,32068,32018,32253,
    32236,32243,32258,32216,32212,32218,32019,32411,31929,31914,31907,31903,31958,31933,31041,
    31042,31968,31044,31045,31955,31046,31047,31099,31043,31097,31931,31918,31086,31927,31966,
    21943,31963,31952,31964,31962,31908,31072,31941,31961,31928,31054,31033,31059,31057,31061,
    31056,31055,31909,31912,31065,31032,31074,31078,32419,31957,31954,31946,31972,31060,31938,
    31013,31002,31007,31000,31003,31096,31070,31039,31034,31025,31038,31026,31050,31940,31089,
    31031,31051,31937,31016,31018,31039,31015,31917,31076,31939,32409
]
```

```{python}
# Define background of Washington D.C.
response1 = requests.get('https://raw.githubusercontent.com/arcee123/GIS_GEOJSON_CENSUS_TRACTS/master/11.geojson')

background = alt.Chart(alt.Data(values=response1.json())).mark_geoshape(
        fill="lightgray",
        stroke='white',
        strokeWidth=1
    ).encode(
    ).properties(
        width=600,
        height=600
    )

# Create mouseover selection
select_station = alt.selection_single(
    on="mouseover", nearest=True, fields=["start_station_name"], empty='none'
)

# Filter non-DC stations
tmp1 = bikeshare_df[~bikeshare_df['start_station_id'].isin(nondc_stations)]
tmp1 = tmp1[~tmp1['end_station_id'].isin(nondc_stations)]
# Keep only relevant columns and drop duplicates to have one row per route
tmp1 = tmp1[['start_station_name', 'start_station_id', 'end_station_name', 'end_station_id', 'start_lat', 'start_lng', 'end_lat', 'end_lng']].drop_duplicates()
#tmp = bikeshare_df[['start_station_name', 'start_lat', 'start_lng', 'end_lat', 'end_lng']].drop_duplicates()

# Define connections
connections = alt.Chart(tmp1).mark_rule(opacity=0.35).encode(
    latitude="start_lat:Q",
    longitude="start_lng:Q",
    latitude2="end_lat:Q",
    longitude2="end_lng:Q"
).transform_filter(
    select_station
)

# Filter non-DC stations
tmp2 = bikeshare_df[~bikeshare_df['start_station_id'].isin(nondc_stations)]
tmp2 = tmp2[~tmp2['end_station_id'].isin(nondc_stations)]
# Temporary dataframe showing unique station locations with ride count
tmp2 = tmp2[['start_station_name','start_station_id', 'start_lng', 'start_lat', 'ride_id']].groupby(['start_station_name', 'start_station_id','start_lng', 'start_lat']).agg({'ride_id': 'count'}).reset_index()
tmp2.rename(columns= {'ride_id':'count_rides'}, inplace = True)

points = alt.Chart(tmp2).mark_circle().encode(
    latitude="start_lat:Q",
    longitude="start_lng:Q",
    size=alt.Size("count_rides:Q", scale=alt.Scale(range=[15, 250]), legend=None),
    order=alt.Order("count_rides:Q", sort="descending"),
    tooltip=["start_station_name:N", "start_station_id:Q", "count_rides:Q"]
).add_selection(
    select_station
)

(background + connections + points).configure_view(stroke=None)
#(background  + points).configure_view(stroke=None)
#(background).configure_view(stroke=None)
```